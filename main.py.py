# -*- coding: utf-8 -*-
"""GUAVAAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RIqeI3irHEPd2IhV5VHY0uCPf0F-Tu6R
"""

!pip install flask

import time

def start_simulation(plan_id=None):
    # Placeholder logic — here you'd trigger your 3D rendering pipeline
    time.sleep(1)  # Simulate short delay for processing
    return {
        "simulation_id": "sim-ABC123",
        "message": "3D simulation started",
        "plan_id": plan_id or "default-plan"
    }

from flask import Flask, request, jsonify
# from simulator import start_simulation

app = Flask(__name__)

@app.route('/start-simulation', methods=['POST'])
def simulate():
    data = request.get_json()
    plan_id = data.get('plan_id')  # Optionally pass architectural plan ID
    result = start_simulation(plan_id)
    return jsonify({"status": "started", "details": result})

if __name__ == '__main__':
    app.run(debug=True)

"""# Task
Explain the error in the selected code, fix it, and switch to a production WSGI server.

## Install a production wsgi server

### Subtask:
Choose and install a production-ready WSGI server (e.g., Gunicorn or Waitress).

**Reasoning**:
Install Gunicorn as the production WSGI server since it's generally preferred for Unix-like systems, which is typical in a notebook environment.
"""

! pip install gunicorn



from flask import Flask, request, jsonify
# from simulator import start_simulation

app = Flask(__name__)

@app.route('/start-simulation', methods=['POST'])
def simulate():
    data = request.get_json()
    plan_id = data.get('plan_id')  # Optionally pass architectural plan ID
    result = start_simulation(plan_id)
    return jsonify({"status": "started", "details": result})

if __name__ == '__main__':
    app.run(debug=True)

"""<!DOCTYPE html>
<html>
<head>
    <title>Guava 3D Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: white;
            padding: 10px;
        }
    </style>
</head>
<body>
<div id="controls">
    <input type="file" id="fileInput">
    <button onclick="uploadAndStart()">Start</button>
</div>
<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r148/three.min.js"></script>
<script>
let scene, camera, renderer;

function initViewer() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

function uploadAndStart() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert("Please upload a drawing file");
        return;
    }

    const formData = new FormData();
    formData.append('file', file);

    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(res => res.json())
    .then(data => {
        const filename = data.filename;
        fetch('/start-simulation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filename: filename })
        })
        .then(res => res.json())
        .then(sim => {
            alert("Simulation started: " + sim.details.message);
            // You can now load actual 3D models based on drawing (future step)
        });
    });
}

initViewer();
</script>
</body>
</html>

# Task
Explain the provided Python code for a Flask application and modify it to run using Gunicorn.

## Fix the code

### Subtask:
Modify the Flask application code to address the `NameError: name 'start_simulation' is not defined` by ensuring the `start_simulation` function is imported or defined within the same scope.

**Reasoning**:
The subtask is to fix the `NameError` by ensuring `start_simulation` is accessible. Based on the notebook state, `start_simulation` is defined in a preceding cell. The current Flask code has a commented-out import. The fix is to remove the commented-out import and ensure the cell with the definition of `start_simulation` has been run (which it has, according to the notebook state). Then, re-run the Flask application code cell.
"""

from flask import Flask, request, jsonify
# The start_simulation function is defined in a previous cell, so no need to import it again here
# from simulator import start_simulation

app = Flask(__name__)

@app.route('/start-simulation', methods=['POST'])
def simulate():
    data = request.get_json()
    plan_id = data.get('plan_id')  # Optionally pass architectural plan ID
    # Call the start_simulation function defined in the previous cell
    result = start_simulation(plan_id)
    return jsonify({"status": "started", "details": result})

# This __main__ block is typically used for running the development server.
# We will modify this later to use a production WSGI server like Gunicorn.
# if __name__ == '__main__':
#     app.run(debug=True)

"""## Integrate gunicorn

### Subtask:
Modify the code to run the Flask application using Gunicorn instead of the Flask's built-in development server.

**Reasoning**:
Remove the `if __name__ == '__main__': app.run(debug=True)` block to prepare the Flask application for deployment with Gunicorn.
"""

from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/start-simulation', methods=['POST'])
def simulate():
    data = request.get_json()
    plan_id = data.get('plan_id')
    result = start_simulation(plan_id)
    return jsonify({"status": "started", "details": result})

# The __main__ block is removed as Gunicorn will manage the application lifecycle.
# if __name__ == '__main__':
#     app.run(debug=True)

"""<!DOCTYPE html>

1.   List item

1.   List item
2.   List item


2.   List item


<html>
<head>
    <title>Guava 3D Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: white;
            padding: 10px;
        }
    </style>
</head>
<body>
<div id="controls">
    <input type="file" id="fileInput">
    <button onclick="uploadAndStart()">Start</button>
</div>
<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r148/three.min.js"></script>
<script>
let scene, camera, renderer;

function initViewer() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

function uploadAndStart() {
    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];
    if (!file) {
        alert("Please upload a drawing file");
        return;
    }

    const formData = new FormData();
    formData.append('file', file);

    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(res => res.json())
    .then(data => {
        const filename = data.filename;
        fetch('/start-simulation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filename: filename })
        })
        .then(res => res.json())
        .then(sim => {
            alert("Simulation started: " + sim.details.message);
            // You can now load actual 3D models based on drawing (future step)
        });
    });
}

initViewer();
</script>
</body>
</html>

"""





"""## Summary:

### Data Analysis Key Findings

*   The initial `NameError` was resolved by ensuring the `start_simulation` function, defined in a prior cell, was accessible within the Flask application's scope.
*   To integrate Gunicorn, the `if __name__ == '__main__': app.run(debug=True)` block was removed from the Flask application code, as Gunicorn manages the application lifecycle directly.

### Insights or Next Steps

*   The modified code is now prepared to be served by Gunicorn, allowing for a more robust production deployment compared to Flask's built-in development server.

# Task
Run the flask application located in the `guava_simulator` directory.

## Change the current directory to `guava simulator`.

### Subtask:
Change the current directory to `guava_simulator`.

**Reasoning**:
Change the current directory to `guava_simulator` using the `%cd` magic command as instructed by the subtask.
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd guava_simulator

"""**Reasoning**:
The previous attempt to change the directory failed because `guava_simulator` does not exist. I need to create the directory first before changing into it.


"""

# Commented out IPython magic to ensure Python compatibility.
!mkdir guava_simulator
# %cd guava_simulator

"""## Execute the flask application.

### Subtask:
Execute the Flask application.

**Reasoning**:
Execute the Flask application using Gunicorn as instructed.
"""

!gunicorn app:app -b 0.0.0.0:5000

"""**Reasoning**:
The previous command failed because gunicorn was not found. This indicates that the installation of gunicorn did not persist or was not available in the environment where the command was executed. Re-install gunicorn to ensure it's available.


"""

!pip install gunicorn

"""**Reasoning**:
Gunicorn has been successfully re-installed. Now, attempt to execute the Flask application using Gunicorn again.


"""

!gunicorn app:app -b 0.0.0.0:5000

"""**Reasoning**:
The error "ModuleNotFoundError: No module named 'app'" indicates that Gunicorn cannot find the Flask application file named `app.py`. This is likely because the Python code for the Flask app has not been saved to a file named `app.py` in the current directory. Save the Flask application code to `app.py` and then attempt to run Gunicorn again.


"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# from flask import Flask, request, jsonify
# import time
# 
# def start_simulation(plan_id=None):
#     # Placeholder logic — here you'd trigger your 3D rendering pipeline
#     time.sleep(1)  # Simulate short delay for processing
#     return {
#         "simulation_id": "sim-ABC123",
#         "message": "3D simulation started",
#         "plan_id": plan_id or "default-plan"
#     }
# 
# app = Flask(__name__)
# 
# @app.route('/start-simulation', methods=['POST'])
# def simulate():
#     data = request.get_json()
#     plan_id = data.get('plan_id')
#     result = start_simulation(plan_id)
#     return jsonify({"status": "started", "details": result})
# 
# # The __main__ block is removed as Gunicorn will manage the application lifecycle.
# # if __name__ == '__main__':
# #     app.run(debug=True)

"""**Reasoning**:
The Flask application code has been successfully saved to `app.py`. Now, attempt to run the application using Gunicorn again.


"""

!gunicorn app:app -b 0.0.0.0:5000

from fastapi import FastAPI, UploadFile, File, Form, Depends
from fastapi.responses import JSONResponse
from typing import List, Optional
from pydantic import BaseModel
from datetime import datetime

app = FastAPI()

# -------------------- Models --------------------
class SubscriptionLevel(BaseModel):
    tier: str  # Bronze, Silver, Gold
    level: int  # 1, 2, 3
    price: float
    listings_limit: int
    auto_pushups: bool
    area_specialist: bool
    homepage_logo: bool

class UserProfile(BaseModel):
    contact_name: str
    business_name: str
    email: str
    phone: str
    address: str
    about_organization: Optional[str] = None

class PerformanceStats(BaseModel):
    enquiries: int
    client_requests: int
    lead_stats: dict
    listing_stats: dict
    activity_graph: dict

# -------------------- In-Memory DB Simulation --------------------
subscriptions = [
    SubscriptionLevel(tier="Bronze", level=1, price=10000.00, listings_limit=5, auto_pushups=False, area_specialist=False, homepage_logo=False),
    SubscriptionLevel(tier="Bronze", level=2, price=12000.00, listings_limit=10, auto_pushups=False, area_specialist=True, homepage_logo=False),
    SubscriptionLevel(tier="Bronze", level=3, price=15000.00, listings_limit=15, auto_pushups=True, area_specialist=True, homepage_logo=False),
    SubscriptionLevel(tier="Silver", level=1, price=20000.00, listings_limit=25, auto_pushups=True, area_specialist=True, homepage_logo=True),
    SubscriptionLevel(tier="Silver", level=2, price=25000.00, listings_limit=35, auto_pushups=True, area_specialist=True, homepage_logo=True),
    SubscriptionLevel(tier="Silver", level=3, price=35000.00, listings_limit=45, auto_pushups=True, area_specialist=True, homepage_logo=True),
    SubscriptionLevel(tier="Gold", level=1, price=60000.00, listings_limit=60, auto_pushups=True, area_specialist=True, homepage_logo=True),
    SubscriptionLevel(tier="Gold", level=2, price=75000.00, listings_limit=75, auto_pushups=True, area_specialist=True, homepage_logo=True),
    SubscriptionLevel(tier="Gold", level=3, price=80000.00, listings_limit=100, auto_pushups=True, area_specialist=True, homepage_logo=True),
]

user_profiles = {}
performance_data = {}

# -------------------- Routes --------------------
@app.get("/dashboard")
def dashboard():
    return {"message": "Welcome to the Guava App Property Finder Backend"}

@app.get("/subscriptions")
def get_subscriptions():
    return subscriptions

@app.post("/profile")
def create_or_update_profile():
    pass

pip install fastapi[all] python-jose[cryptography] passlib[bcrypt] python-multipart

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext

SECRET_KEY = "your-super-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Dummy DB
users_db = {}

class User(BaseModel):
    email: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def authenticate_user(email: str, password: str):
    user = users_db.get(email)
    if not user:
        return False
    if not verify_password(password, user['password']):
        return False
    return user

def create_access_token(data: dict):
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

@app.post("/register")
def register(user: User):
    if user.email in users_db:
        return {"error": "User already exists"}
    users_db[user.email] = {
        "email": user.email,
        "password": get_password_hash(user.password)
    }
    return {"message": "User registered successfully"}

@app.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect email or password")
    token = create_access_token(data={"sub": user['email']})
    return {"access_token": token, "token_type": "bearer"}

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email = payload.get("sub")
        if email is None or email not in users_db:
            raise HTTPException(status_code=401, detail="Invalid token")
        return users_db[email]
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

requirements = """
fastapi==0.111.0
uvicorn[standard]==0.29.0
python-multipart==0.0.9
sqlalchemy==2.0.30
pydantic==2.7.1
pydantic-settings==2.2.1
passlib[bcrypt]==1.7.4
python-jose[cryptography]==3.3.0
python-dotenv==1.0.1
aiofiles==23.2.1
jinja2==3.1.4
httpx==0.27.0
"""

with open("requirements.txt", "w") as file:
    file.write(requirements)

print("✅ requirements.txt created successfully!")

from google.colab import files
files.download("requirements.txt")

!git rm -r --cached .venv/
!git commit -m "Remove venv from tracking"
!git push origin main

"""## Summary:

### Data Analysis Key Findings

*   Initially, the directory `guava_simulator` did not exist, leading to a failed attempt to change the current directory. The directory was then successfully created.
*   Attempting to run the Flask application with `gunicorn` failed because `gunicorn` was not installed.
*   After installing `gunicorn`, the execution failed again because the `app.py` file containing the Flask application code was missing.
*   Creating the `app.py` file with the provided Flask code resolved the missing module error.
*   The final execution of the Flask application using `gunicorn` was successful, and the server started listening on port 5000.

### Insights or Next Steps

*   The Flask application is now running and can be accessed at `http://0.0.0.0:5000`.
*   The next steps involve interacting with the running Flask application, likely by sending a POST request to the `/start-simulation` endpoint.

"""

!git status

import requests

response = requests.get("https://guava-backend-2.onrender.com/api/listings")

# Check the status code
print(f"Status Code: {response.status_code}")

# Print the response text
print("Response Text:")
print(response.text)

# Try to parse as JSON only if the status code is successful (e.g., 200)
try:
    response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
    print("\nResponse JSON:")
    print(response.json())
except requests.exceptions.HTTPError as e:
    pass # Removed the print statement for HTTPError
except requests.exceptions.JSONDecodeError:
    print("\nError: Could not decode JSON from the response.")
    print("The response content was likely not valid JSON.")
except Exception as e:
    print(f"\nAn unexpected error occurred: {e}")

"""# Task
Edit the code in the GitHub repository "https://github.com/rolandperez007/guava-backend" by incorporating the FastAPI application code from the notebook, install dependencies, run the application, and test it.

## Clone the repository

### Subtask:
Clone the GitHub repository `https://github.com/rolandperez007/guava-backend` to the Colab environment.

**Reasoning**:
Clone the specified GitHub repository into the Colab environment.
"""

!git clone https://github.com/rolandperez007/guava-backend.git

"""## Navigate to the repository directory

### Subtask:
Change the current working directory to the newly cloned repository directory.

**Reasoning**:
Change the current directory to the cloned repository directory `guava-backend` as instructed by the subtask.
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd guava-backend

"""## Transfer code from notebook to repository

### Subtask:
Save the relevant code cells from the notebook (specifically the FastAPI application code and the security-related code) into appropriate file(s) within the cloned repository structure.

**Reasoning**:
Save the FastAPI application code and security-related code into `main.py` within the repository directory using `%%writefile`.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile main.py
# from fastapi import FastAPI, UploadFile, File, Form, Depends, HTTPException
# from fastapi.responses import JSONResponse
# from typing import List, Optional
# from pydantic import BaseModel
# from datetime import datetime
# from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
# from jose import JWTError, jwt
# from passlib.context import CryptContext
# import time # Import time for start_simulation
# 
# app = FastAPI()
# 
# # -------------------- Models --------------------
# class SubscriptionLevel(BaseModel):
#     tier: str  # Bronze, Silver, Gold
#     level: int  # 1, 2, 3
#     price: float
#     listings_limit: int
#     auto_pushups: bool
#     area_specialist: bool
#     homepage_logo: bool
# 
# class UserProfile(BaseModel):
#     contact_name: str
#     business_name: str
#     email: str
#     phone: str
#     address: str
#     about_organization: Optional[str] = None
# 
# class PerformanceStats(BaseModel):
#     enquiries: int
#     client_requests: int
#     lead_stats: dict
#     listing_stats: dict
#     activity_graph: dict
# 
# # -------------------- In-Memory DB Simulation --------------------
# subscriptions = [
#     SubscriptionLevel(tier="Bronze", level=1, price=10000.00, listings_limit=5, auto_pushups=False, area_specialist=False, homepage_logo=False),
#     SubscriptionLevel(tier="Bronze", level=2, price=12000.00, listings_limit=10, auto_pushups=False, area_specialist=True, homepage_logo=False),
#     SubscriptionLevel(tier="Bronze", level=3, price=15000.00, listings_limit=15, auto_pushups=True, area_specialist=True, homepage_logo=False),
#     SubscriptionLevel(tier="Silver", level=1, price=20000.00, listings_limit=25, auto_pushups=True, area_specialist=True, homepage_logo=True),
#     SubscriptionLevel(tier="Silver", level=2, price=25000.00, listings_limit=35, auto_pushups=True, area_specialist=True, homepage_logo=True),
#     SubscriptionLevel(tier="Silver", level=3, price=35000.00, listings_limit=45, auto_pushups=True, area_specialist=True, homepage_logo=True),
#     SubscriptionLevel(tier="Gold", level=1, price=60000.00, listings_limit=60, auto_pushups=True, area_specialist=True, homepage_logo=True),
#     SubscriptionLevel(tier="Gold", level=2, price=75000.00, listings_limit=75, auto_pushups=True, area_specialist=True, homepage_logo=True),
#     SubscriptionLevel(tier="Gold", level=3, price=80000.00, listings_limit=100, auto_pushups=True, area_specialist=True, homepage_logo=True),
# ]
# 
# user_profiles = {}
# performance_data = {}
# 
# # -------------------- Routes --------------------
# @app.get("/dashboard")
# def dashboard():
#     return {"message": "Welcome to the Guava App Property Finder Backend"}
# 
# @app.get("/subscriptions")
# def get_subscriptions():
#     return subscriptions
# 
# @app.post("/profile")
# def create_or_update_profile():
#     pass
# 
# # -------------------- Security Code --------------------
# SECRET_KEY = "your-super-secret-key"
# ALGORITHM = "HS256"
# ACCESS_TOKEN_EXPIRE_MINUTES = 60
# 
# pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
# oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
# 
# # Dummy DB (already defined above, no need to redefine)
# # users_db = {}
# 
# class User(BaseModel):
#     email: str
#     password: str
# 
# class Token(BaseModel):
#     access_token: str
#     token_type: str
# 
# def verify_password(plain_password, hashed_password):
#     return pwd_context.verify(plain_password, hashed_password)
# 
# def get_password_hash(password):
#     return pwd_context.hash(password)
# 
# def authenticate_user(email: str, password: str):
#     user = users_db.get(email)
#     if not user:
#         return False
#     if not verify_password(password, user['password']):
#         return False
#     return user
# 
# def create_access_token(data: dict):
#     return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)
# 
# @app.post("/register")
# def register(user: User):
#     if user.email in users_db:
#         return {"error": "User already exists"}
#     users_db[user.email] = {
#         "email": user.email,
#         "password": get_password_hash(user.password)
#     }
#     return {"message": "User registered successfully"}
# 
# @app.post("/token", response_model=Token)
# async def login(form_data: OAuth2PasswordRequestForm = Depends()):
#     user = authenticate_user(form_data.username, form_data.password)
#     if not user:
#         raise HTTPException(status_code=400, detail="Incorrect email or password")
#     token = create_access_token(data={"sub": user['email']})
#     return {"access_token": token, "token_type": "bearer"}
# 
# async def get_current_user(token: str = Depends(oauth2_scheme)):
#     try:
#         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
#         email = payload.get("sub")
#         if email is None or email not in users_db:
#             raise HTTPException(status_code=401, detail="Invalid token")
#         return users_db[email]
#     except JWTError:
#         raise HTTPException(status_code=401, detail="Invalid token")
# 
# # Include the start_simulation function from the previous notebook cell
# def start_simulation(plan_id=None):
#     # Placeholder logic — here you'd trigger your 3D rendering pipeline
#     time.sleep(1)  # Simulate short delay for processing
#     return {
#         "simulation_id": "sim-ABC123",
#         "message": "3D simulation started",
#         "plan_id": plan_id or "default-plan"
#     }
# 
# # Include the Flask simulation endpoint logic adapted for FastAPI
# @app.post("/start-simulation")
# async def simulate(plan_id: Optional[str] = None):
#     result = start_simulation(plan_id)
#     return {"status": "started", "details": result}

"""## Install dependencies

### Subtask:
Install the necessary Python dependencies listed in the `requirements.txt` file (or equivalent) from the cloned repository.

**Reasoning**:
I will now install the required packages from the `requirements.txt` file. This is a necessary step before attempting to run the application.
"""

!pip install -r requirements.txt

"""**Reasoning**:
The previous command failed due to a dependency conflict between `databases==0.8.0` and `sqlalchemy==2.0.30`. I need to modify the `requirements.txt` file to remove the `databases` dependency, as it's not directly used in the provided FastAPI code, which relies on in-memory data structures.


"""

requirements = """
fastapi==0.111.0
uvicorn[standard]==0.29.0
python-multipart==0.0.9
sqlalchemy==2.0.30
# databases==0.8.0  # Removed due to dependency conflict
pydantic==2.7.1
pydantic-settings==2.2.1
passlib[bcrypt]==1.7.4
python-jose[cryptography]==3.3.0
python-dotenv==1.0.1
aiofiles==23.2.1
jinja2==3.1.4
httpx==0.27.0
email-validator==2.1.1
"""

with open("requirements.txt", "w") as file:
    file.write(requirements)

print("✅ requirements.txt updated successfully!")

"""**Reasoning**:
I have updated the `requirements.txt` file to resolve the dependency conflict. Now I need to re-attempt installing the dependencies using the modified `requirements.txt` file.


"""

!pip install -r requirements.txt

"""## Run the application from the repository

### Subtask:
Execute the FastAPI application using a suitable server (like Uvicorn) from within the repository directory.

**Reasoning**:
Execute the FastAPI application using Uvicorn as instructed by the subtask.
"""

!uvicorn main:app --host 0.0.0.0 --port 8000 &

"""## Test the running application

### Subtask:
Make a request to the running application endpoint to verify it's working as expected.

**Reasoning**:
Send a GET request to the /dashboard endpoint of the running FastAPI application and print the status code and JSON response.
"""

!git config --global user.email "your@email.com"
!git config --global user.name "GuavaDev"

!git add .
!git commit -m "Updated backend"
!git push origin main

# just added  comment
print ("Backend loaded")
!git add .
!git commit -m "Trigger redeploy: clean commit"
!git push origin main

pip freeze

"""## Test the running application

### Subtask:
Make a request to the running application endpoint to verify it's working as expected.

**Reasoning**:
Send a GET request to the `/dashboard` endpoint of the running FastAPI application and print the status code and JSON response.
"""

!gunicorn main:app --bind 0.0.0.0:10000

"""**Reasoning**:
The previous command failed because `gunicorn` was not found. This indicates that `gunicorn` is not installed in the current environment. Install `gunicorn` using `pip`.
"""

!pip install gunicorn

import requests

response = requests.get("http://localhost:8000/dashboard")
print("Status code:", response.status_code)
print("Response JSON:", response.json())

"""## Test the running application

### Subtask:
Make a request to the running application endpoint to verify it's working as expected.

**Reasoning**:
Send a GET request to the `/dashboard` endpoint of the running FastAPI application and print the status code and JSON response.
"""

import requests

# Assuming the application is running on localhost:10000
url = "http://localhost:10000/dashboard"

try:
    response = requests.get(url)
    response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)

    print(f"Status Code: {response.status_code}")
    print("Response JSON:")
    print(response.json())

except requests.exceptions.RequestException as e:
    print(f"Error making request: {e}")
    print("Please ensure the FastAPI application is running in a separate cell or process.")

requirements = """
fastapi
uvicorn
python-multipart
passlib[bcrypt]
python-jose[cryptography]
"""

with open("requirements.txt", "w") as file:
    file.write(requirements)

print("✅ requirements.txt created successfully!")

"""## Install dependencies

### Subtask:
Install the necessary Python dependencies listed in the `requirements.txt` file from the cloned repository.

**Reasoning**:
Install the required packages from the `requirements.txt` file using `pip`.
"""

!pip install -r requirements.txt

"""## Commit and push changes to GitHub

### Subtask:
Commit the updated `main.py` and `requirements.txt` files to the local repository and push the changes to the remote GitHub repository.

**Reasoning**:
Add all changes in the current directory to the staging area, commit them with a descriptive message, and push the committed changes to the `main` branch of the remote repository.
"""

!git add .
!git commit -m "Add main.py and update requirements.txt for FastAPI"
!git push origin main

"""## Download updated files

### Subtask:
Download the updated `main.py` and `requirements.txt` files from the Colab environment to your local machine.

**Reasoning**:
Use the `files.download()` function from `google.colab` to download the `main.py` and `requirements.txt` files.

**Reasoning**:
The previous attempts to download `main.py` failed because the current directory was not set to `guava-backend`. Change the directory to `guava-backend` before attempting to download the files.
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd guava-backend

"""## Clone the repository

### Subtask:
Clone the GitHub repository `https://github.com/rolandperez007/guava-backend` to the Colab environment.

**Reasoning**:
Clone the specified GitHub repository into the Colab environment.
"""

!git clone https://github.com/rolandperez007/guava-backend.git

"""## Navigate to the repository directory

### Subtask:
Change the current working directory to the newly cloned repository directory.

**Reasoning**:
Change the current directory to the cloned repository directory `guava-backend` as instructed by the subtask.
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd guava-backend

"""## Download updated files

### Subtask:
Download the updated `main.py` and `requirements.txt` files from the Colab environment to your local machine.

**Reasoning**:
Use the `files.download()` function from `google.colab` to download the `main.py` and `requirements.txt` files.
"""